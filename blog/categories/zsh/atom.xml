<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: zsh | My Blog]]></title>
  <link href="http://edkolev.github.io/blog/categories/zsh/atom.xml" rel="self"/>
  <link href="http://edkolev.github.io/"/>
  <updated>2014-01-26T19:14:58+02:00</updated>
  <id>http://edkolev.github.io/</id>
  <author>
    <name><![CDATA[Evgeni Kolev]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[prompt shorten working directory]]></title>
    <link href="http://edkolev.github.io/blog/2014/01/26/prompt-shorten-working-directory/"/>
    <updated>2014-01-26T12:03:54+02:00</updated>
    <id>http://edkolev.github.io/blog/2014/01/26/prompt-shorten-working-directory</id>
    <content type="html"><![CDATA[<h2>TL;DR</h2>

<p>Shorten <code>~/very/deep/down/the/rabbit/hole</code> to <code>⋯/the/rabbit/hole</code> in
prompt.</p>

<!-- more -->


<p>If you&rsquo;re staring at a shell prompt a few hours every day, you might as well
modify the prompt to better suit your needs.  Some people like a minimalistic
prompt with nothing but the working dir and a dollar sight <code>~ $</code>.  Others get
an enormous 256-color multi-line beast holding information about the kernel
version, battery status, daily horoscope and what not. There&rsquo;s yet another
group which sticks with whatever their system&rsquo;s default is.</p>

<p>This post will hopefully come in handy for the first and second groups.</p>

<h2>The Goal</h2>

<p>The working directory should be readable no matter how
<code>~/very/deep/down/the/rabbit/hole</code> you&rsquo;re in in the file system. To maintain
readability, the working dir displayed in the prompt should contain no more
than three sub directories <code>⋯/the/rabbit/hole</code></p>

<p>Bash version 4+ actually has an option to do this <code>PROMPT_DIRTRIM=3</code>, but I
find it&rsquo;s behaviour ludicrous: it behaves (very) differently when the working
dir is a sub dir of $HOME or not.</p>

<p>Working dir is a subdir of $HOME:</p>

<p><code>sh
~ $ PROMPT_DIRTRIM=3
~ $ cd one/
~/one $ cd two/
~/one/two $ cd three/
~/one/two/three $ cd four/
~/one/two/three/four $ cd five/
~/.../three/four/five $
</code></p>

<p>This is useless to me:</p>

<ul>
<li>Notice that when in dir <code>four</code>, the path is not truncated at all
<code>~/one/two/three/four $</code></li>
<li>The tilde <code>~</code> is never truncated <code>~/.../three/four/five $</code></li>
</ul>


<p>Working dir is not a subdir of $HOME:</p>

<p><code>sh
~ $ PROMPT_DIRTRIM=3
/ $ cd one/
/one $ cd two/
/one/two $ cd three/
/one/two/three $ cd four/
.../two/three/four $ cd five/
.../three/four/five $
</code></p>

<p>This is much better! &hellip; or not:</p>

<ul>
<li>Most of the time I&rsquo;m somewhere in $HOME</li>
<li>I would really like to use a single char <code>⋯</code> instead of three dots <code>...</code>.
Screen real-estate does not come that cheap. I work with many vim/tmux panes,
so cutting some fat here and there does make a difference.</li>
</ul>


<p>Also, I&rsquo;ve been wanting to improve my shell scripting skills for some time.
This seemed like a nice challenge.</p>

<h2>Truncate function</h2>

<p>In theory, truncating the $PWD to 3 dirs seemed like a very simple task. In
practice, it turned out a (tiny) bit more complicated. In javascript (a
language I&rsquo;m mostly unfamiliar with), this could be achieved with pretty much
one line of code:</p>

<p>(Note that this is greatly simplified and doesn&rsquo;t handle any corner cases.)
<code>javascript
PWD.split('/').slice(-3).join('/')
</code></p>

<p>How hard could it be to port this to bash (and zsh)?</p>

<p>One thing I want to stress is that external processes must <strong>not</strong> be created
to achieve this task. This function must be as fast as possible and forking off
<code>sed</code>, <code>awd</code> and what not, is not a viable option.</p>

<h2>The result</h2>

<p>After some research on bash/zsh arrays, some head-banging and quite a bit of
coffee, I managed to achieve the desired result:</p>

<p>In a subdir of $HOME:</p>

<p><code>sh
~ $ cd one/
~/one $ cd two/
~/one/two $ cd three/
⋯/one/two/three $ cd four/
⋯/two/three/four $ cd five/
</code></p>

<p>Not in $HOME:</p>

<p><code>sh
/ $ cd one/
/one $ cd two/
/one/two $ cd three/
⋯/one/two/three $ cd four/
⋯/two/three/four $ cd five/
</code></p>

<p>As a bonus, the separator can be configured, for example it could be <code>&gt;</code></p>

<p><code>sh
~ $ cd one/
~ &gt; one $ cd two/
~ &gt; one &gt; two $ cd three/
⋯ &gt; one &gt; two &gt; three $ cd four/
⋯ &gt; two &gt; three &gt; four $ cd five/
</code></p>

<p>Plus, with some minor modifications, I got the function working with powerline
symbols for my <a href="https://github.com/edkolev/promptline.vim">promptline.vim</a> plugin:</p>

<p><img src="/images/promptline_cwd.png"></p>

<h2>The function itself</h2>

<p>Hopefully it would be useful to someone else. I certainly learned a lot writing
(and re-writing) it. Enjoy!</p>

<p>``` sh
function truncated_cwd {
  # dir_limit and truncation can be configured
  local dir_limit=&ldquo;3&rdquo;
  local truncation=&ldquo;⋯&rdquo;</p>

<p>  local first_char
  local part_count=0
  local formatted_cwd=&ldquo;&rdquo;
  local dir_sep=&ldquo; | &rdquo;</p>

<p>  local cwd=&ldquo;${PWD/#$HOME/~}&rdquo;</p>

<p>  # get first char of the path, i.e. tilde or slash
  [[ -n ${ZSH_VERSION-} ]] &amp;&amp; first_char=$cwd[1,1] || first_char=${cwd::1}</p>

<p>  # remove leading tilde
  cwd=&ldquo;${cwd#\~}&rdquo;</p>

<p>  while [[ &ldquo;$cwd&rdquo; == <em>/</em> &amp;&amp; &ldquo;$cwd&rdquo; != &ldquo;/&rdquo; ]]; do</p>

<pre><code># pop off last part of cwd
local part="${cwd##*/}"
cwd="${cwd%/*}"

formatted_cwd="$dir_sep$part$formatted_cwd"
part_count=$((part_count+1))

[[ $part_count -eq $dir_limit ]] &amp;&amp; first_char="$truncation" &amp;&amp; break
</code></pre>

<p>  done</p>

<p>  [[ &ldquo;$formatted_cwd&rdquo; != $first_char* ]] &amp;&amp; formatted_cwd=&ldquo;$first_char$formatted_cwd&rdquo;
  printf &ldquo;%s&rdquo; &ldquo;$formatted_cwd&rdquo;
}
```</p>

<p>There are a few ways to get the function in the prompt, this is probably the
simplest one:</p>

<p><code>sh
PS1='$(truncated_cwd) \$ '
</code></p>
]]></content>
  </entry>
  
</feed>
