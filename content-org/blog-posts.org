#+hugo_base_dir: ../
#+hugo_section: posts

#+hugo_weight: auto
#+hugo_auto_set_lastmod: nil
#+hugo_code_fence: nil

* About
:PROPERTIES:
:EXPORT_FILE_NAME: about
:EXPORT_HUGO_SECTION: /
:EXPORT_HUGO_MENU: :menu main
:END:

My name is Evgeni, this is my personal blog where I write about
whatever Iâ€™m interested in at the time of writing.

Content on this blog is reusable under CC BY-SA 4.0

The source of this site is on [[https://github.com/edkolev/edkolev.github.io/tree/source][github]]

* Posts                                                              :@posts:


** On AI and writing                            :artificial_intelligence:
:PROPERTIES:
:EXPORT_FILE_NAME: on-ai-and-writing
:EXPORT_DATE: 2024-12-14
:END:

I'm so *excited* by AI. I'm a bit *upset* by AI. Oh...

#+hugo: more

*** Artificial intelligence era

AI *will* affect the tech industry.

I'm looking forward to the AI era of software engineering. I expect many changes, mostly to the
way we interact with code. Other than that, my prediction is the bulk of challenges in software
development, like building the right product, getting feedback from end users, solving actual
business needs, will not undergo a drastic change. Sure, the name of the role "software
engineer" might change, the responsibilities might change... but at the end of the day, only a
small section of the job will change, only the interactions with code.

Note, I'm completely ignoring claims like Poolside's claim that they will build and AI which
will match end even surpass software engineers. I don't deny this can/will happen, I'm ignoring
it because I see it as too far in the future.

Note2, I'm also ignoring the very likely possibility that demand for software engineers might
change. Instead, I'm making an assumption demand will not change a lot.

*** Opportunities

Speed, correctness, safety and more speed!

There are aspects of AI which are of little interest to me, like which AI company got a bigger
series funding, why was the funding irrational, or why was it visionary.

My current interest with AI lies mostly in:
- addressing end-user needs
- developer productivity

I know a company which exposes APIs for remote device management. Taking advantage of this
would typically mean having their engineers integrate with this API. However, with AI, the
company was able to just expose a chatbot, which understand plain human commands, like "restart
the device in this location". Absolutely no engineering effort needed to integrate with the
API, just use the exposed functionality via the chatbot.

I know a backend engineer who hadn't touched frontend code in years, but recently they "wrote"
thousands of lines of frontned code in mere days. Done exclusively with an AI-powered IDE. Oh,
this is so exciting.

I know a non-engineer who needed a plain Android app to show a timer. Using AI, he was able to
generate code for an app which does exactly this. He did this over a weekend, with *no*
previous Android coding knowledge. Now, he has a phone in his fitness center, which runs this
app 24/7.

*** Joy and Fear

I do not feel threatened by this change (revolution?), on the contrary, I feel like the best is
yet to come - this profession will evolve in interesting, challenging ways... mostly.

There is one part of the job that I *do* feel... afraid.

It's writing. I just love writing, everything about it.

Expressing thoughts, conveying a message, condensing chaotic thoughts into succinct sentences. Not
really related to coding, more about person-to-person communication. Writing *code* is a small part
of the job, writing *thoughts* is a huge part.

After so many years (I'm deliberately not keeping count ðŸ™ˆ) in tech, I still enjoy:
- Starting a blank design document in Google Docs
- Writing down daily notes in Emacs' Org-mode

My only concern with AI, LLMs in particular, is that writing *thoughts* will become obsolete. I
mean not completely obsolete, but it will become crippled, irrelevant, and won't be part of my
daily work.

I don't want that, I want to continue writing...

*** Conclusion

I'm expecting this new era with multiple layers of hope.

Hope that the aspects of the job which are truly enjoyable for me will not be diminished.

Hope that the aspects of the job which are repetitive will become automated to the next level.

Hope that expressing thoughts in written format will not become obsolete.


** Why I'm still using Emacs                                         :emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: why-im-still-using-emacs
:EXPORT_DATE: 2024-12-07
:END:

I've been using Emacs for 8 years as of now, and Vim for 4-5 before
that. Everybody I've ever worked with knows very well *what* I use...
but not necessarily *why* I use it. So why?

#+hugo: more

This post will try to answer this question that I so often get - why
Emacs? The question makes sense - there are so many options, so many
IDEs available. Some of them are pretty much the norm, like VS Code
and JetBrains.

*** But it's not just Emacs

Actually I use both Emacs and Vim... and a bunch of other tools in
day-to-day coding. For example tmux, bash, git, ripgrep. Arguably,
every tool is an integral part of my workflow, it doesn't make sense
to look at individual tools, instead, everything together is what
makes my software development experience what it is.

Still, let's focus on the big question - why Emacs?

This post will try to provide an objective analysis of the pros and
cons, hoping to be as objective as possible. However, with me being
me, and my biases being my biases, it's unlikely I'll be able to
really do an objective analysis... But here it goes anyway.

*** TL;DR;

I like it. I like so many aspects of using Emacs - from day-to-day
writing in it, to periodically checking what new features have been
implemented in the core, and the ecosystem. I enjoy org-mode (I'm
writing this post in org-mode), evil, Elisp, magit to name a few. But
even more I'm impressed with the life of the *project* - In March 2025
*the project will turn 40... years!*

*** Pros

- Learning a Lisp dialect, Elisp, has been a great experience for me.
  I enjoy learning programming languages, I enjoy learning in general.
  Since Lisps are so different from my day-to-day programming
  languages, it was a mind-bending experience.

- Personalised workflow. I know what I want from my development
  environment, and I can achieve it with Emacs. The level of
  personalisation is amazing, so many things can be customized. An
  example: I like modal editing, so I use [[https://github.com/emacs-evil/evil][evil]]. I use RET (enter key)
  to save the file - this is probably the most often used key for me.

- Open source, and warm community. I've contributed [[https://git.savannah.gnu.org/cgit/emacs.git/log/?qt=author&q=evgeni+kolev][multiple times]] to
  Emacs. I don't consider myself a strong Elisp programmer, however,
  the community has been so responsive, so welcoming, I've practically
  been guided multiples times to make my contributions.

*** Cons

The Cons here not really Cons for my. I'm listing them because from my
discussions with fellow engineers, these are generally seen as
negatives. For example, I enjoy doing research on how [[https://microsoft.github.io/language-server-protocol/][LSP]] / [[https://microsoft.github.io/debug-adapter-protocol/][DAP]] work.
However, I acknowledge most people prefer having an IDE which just
works, without exposing under-the-hood details like LSP or DAP.

- Requires maintenance. My Emacs configuration is quite big (a few
  thousand lines), so as the ecosystem evolves, I occasionally do some
  housekeeping to keep it up-to-date, and make sure I'm taking
  advantage of latest features (e.g. native compilation).

- Requires research. Like mentioned above, LSP or DAP is a good
  example. Also, Emacs has different packages for both LSP (e.g. [[https://github.com/joaotavora/eglot][eglot]]
  VS [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]]) and DAP (e.g. [[https://github.com/svaante/dape][dape]] VS [[https://github.com/emacs-lsp/dap-mode][dap-mode]]), just picking one of
  these requires some work.

- Requires in-depth knowledge. Things *will* break. For example Go's
  [[https://github.com/golang/tools/blob/master/gopls/README.md][gopls]] might be upgraded and stop working as a result, which will
  require some intervention to fix. The ecosystem is huge, and the
  ecosystem does not stop evolving. Things break, and someone has to
  fix them.

*** Conclusion

I never mentioned speed, speed is not a factor for me. I acknowledge my
speed for certain tasks can be extremely fast, however, some other
tasks can be much slower. Still, this does not make much of a
difference from my experience. Coding or reading/exploring code are
just a small part of the daily work. I believe the limiting factor is
not the editor/IDE, but the human factor.

I make an analogy with driving a nice car - a nice car is not faster than
any other modern car, assuming speed limit are obeyed.

Still, driving the nice car is more pleasant, more enjoyable.

This is Emacs for me - pleasant, enjoyable!

** Thoughts on all-remote                                             :work:
:PROPERTIES:
:EXPORT_FILE_NAME: thoughts-on-all-remote-companies
:EXPORT_DATE: 2018-12-10
:END:

Working in an all-remote company has always been an interesting
thought exercise to me. Would it work for me? Would it work for the
company? At what cost?

#+hugo: more

*** Pluses

Let's settle on the positives first, starting with the big one: one
could work with his pajamas all day! While this might not sound
serious, it implies a couple of subtleties - the office is where you
when it to be. You want to work from your couch? Sure. How about that
cosy coffee shop nearby? Of course. Maybe the coffee shop which is
right next to the park, and now that the park is mentioned, it doesn't
sound as such a bad office idea either. Definitely! And maybe
occasionally you would just go to the company office and meet up with
the people you work with because you are a human being, just like
them, and you do feel the occasional need to socialize. Hum.. sorry,
this won't work - "all-remote", remember? There isn't such a thing as
a company office when doing all-remote. Not only that, but the chances
of too many people working in the same time zone as you are slim...

Let's get back to the positives, though, this is the =pluses= section!

Undoubtedly, your company would have a huge pool of engineers to chose
from. How big? People from all over the world! That big! That's a
definite win for you when considering whether to join such a company -
you won't ever have to worry about whether relocating makes sense for
you in this phase of your life.

Now that joining such a company is mentioned - hiring is likely to be
"special" - expect an intense series of interviews, each testing your
ability to work in a remote team. You might get chat-only interviews
since chat will likely be the most widely and commonly used
communication channel for the whole company. It makes sense to have
all your interviews online, sending text messages only. No voice, no
video.

*** Negatives

Working by yourself for long periods of time seems like the most
obvious challenge. I guess for myself it would be no more than a month
before I feel a need for in-person human interactions. Nevertheless,
this need varies widely between people. I can easily imagine someone
who never really start craving a face-to-face dialogue. Your mileage
may vary, just be careful not to fall into the trap that is working
with your pajamas, all day, every day...

*** Conclusion

For the company, having a global pool of talent is an obvious win.
Nevertheless, special care has to be taken when figuring out how many
people in the company will be remote and how many - in an office. I
don't believe you can mix and match here, so the only viable, long
term option in my (limited, biased) opinion, is all-remote. This post
is about all-remote companies so I won't bother going into details why
a hybrid model wouldn't be easy, if at all, to pull.

For the individual, working with people from different parts of the
world, different time zones, seems like a lot of fun. Until you need
to have an all-hands meeting, that is. If you're slightly lucky
however, you could easily have top-notch colleagues from all around
Earth, and be able to learn a lot from them. And all from the comfort
of your own couch!

** Quick Start emacs with evil                                       :emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: quick-start-evil-mode
:EXPORT_DATE: 2018-01-13
:EXPORT_DESCRIPTION: using use-package
:END:

This post is intended to present a minimal example of setting up emacs
with evil as well as a few evil plugins.

#+hugo: more

The emacs ecosystem is constantly changing, and evil and its plugins,
being part of that ecosystem, are changing as well. Hence, the snippet
below will be updated as I see fit.

Care is taken to ensure the evil packages are lazy-loaded.

#+begin_src
  ;; load package manager, add the Melpa package registry
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)

  ;; bootstrap use-package
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)

  (use-package evil
    :ensure t
    :defer .1 ;; don't block emacs when starting, load evil immediately after startup
    :init
    (setq evil-want-integration nil) ;; required by evil-collection
    (setq evil-search-module 'evil-search)
    (setq evil-ex-complete-emacs-commands nil)
    (setq evil-vsplit-window-right t) ;; like vim's 'splitright'
    (setq evil-split-window-below t) ;; like vim's 'splitbelow'
    (setq evil-shift-round nil)
    (setq evil-want-C-u-scroll t)
    :config
    (evil-mode)

    ;; vim-like keybindings everywhere in emacs
    (use-package evil-collection
      :after evil
      :ensure t
      :config
      (evil-collection-init))

    ;; gl and gL operators, like vim-lion
    (use-package evil-lion
      :ensure t
      :bind (:map evil-normal-state-map
                  ("g l " . evil-lion-left)
                  ("g L " . evil-lion-right)
                  :map evil-visual-state-map
                  ("g l " . evil-lion-left)
                  ("g L " . evil-lion-right)))

    ;; gc operator, like vim-commentary
    (use-package evil-commentary
      :ensure t
      :bind (:map evil-normal-state-map
                  ("gc" . evil-commentary)))

    ;; gx operator, like vim-exchange
    ;; NOTE using cx like vim-exchange is possible but not as straightforward
    (use-package evil-exchange
      :ensure t
      :bind (:map evil-normal-state-map
                  ("gx" . evil-exchange)
                  ("gX" . evil-exchange-cancel)))

    ;; gr operator, like vim's ReplaceWithRegister
    (use-package evil-replace-with-register
      :ensure t
      :bind (:map evil-normal-state-map
                  ("gr" . evil-replace-with-register)
                  :map evil-visual-state-map
                  ("gr" . evil-replace-with-register)))

    ;; * operator in vusual mode
    (use-package evil-visualstar
      :ensure t
      :bind (:map evil-visual-state-map
                  ("*" . evil-visualstar/begin-search-forward)
                  ("#" . evil-visualstar/begin-search-backward)))

    ;; ex commands, which a vim user is likely to be familiar with
    (use-package evil-expat
      :ensure t
      :defer t)

    ;; visual hints while editing
    (use-package evil-goggles
      :ensure t
      :config
      (evil-goggles-use-diff-faces)
      (evil-goggles-mode))

    ;; like vim-surround
    (use-package evil-surround
      :ensure t
      :commands
      (evil-surround-edit
       evil-Surround-edit
       evil-surround-region
       evil-Surround-region)
      :init
      (evil-define-key 'operator global-map "s" 'evil-surround-edit)
      (evil-define-key 'operator global-map "S" 'evil-Surround-edit)
      (evil-define-key 'visual global-map "S" 'evil-surround-region)
      (evil-define-key 'visual global-map "gS" 'evil-Surround-region))

    (message "Loading evil-mode...done"))
#+end_src

# Local Variables:
# eval: (add-hook 'after-save-hook #'org-hugo-export-wim-to-md-after-save :append :local)
# End:

** Make :only ex command reversible                                  :emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: reversable-ex-only-command
:EXPORT_DATE: 2017-09-22
:EXPORT_DESCRIPTION: like zoom/un-zoom
:END:

The =:only= ex command is one of my most used ones. Here's how it can
be tweaked so that it doesn't only (pun intended) hide all the other
windows, but it restores them when re-executed. it You can think of it
as a zoom/un-zoom command.

#+hugo: more

#+begin_src
(use-package zygospore
  :ensure t
  :commands zygospore-toggle-delete-other-windows
  :init
  (evil-ex-define-cmd "only" 'zygospore-toggle-delete-other-windows))
#+end_src

The above snippet uses the [[https://github.com/louiskottmann/zygospore.el][zygospore]] package, which is but a thin
wrapper around emacs core functionality. Go ahead and check out its code.

I often enter =:On= instead of =:on= which results in a disruption of
my flow with an unpleasant "Unknown command" message. Why not create
an alias then?

#+begin_src
(evil-ex-define-cmd "Only" "only")
#+end_src

** Travis CI integration for emacs packages                          :emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: travis-for-emacs-packages
:EXPORT_DATE: 2017-09-10
:EXPORT_DESCRIPTION: to run automated tests
:END:

This post will show how to add simple make-based testing support for
running automated emacs `ert` tests.

#+hugo: more

The following utilities will be available on the development machine:

- `make update` will install the development dependencies
- `make compile` will compile the .el files
- `make test` will run the `ert` tests
- `make clean` will remove the compiled files

The Travis build will fail with an error when:

- a compilation warning or error occurs
- an automated test fails

This will be the resulting directory structure, where `<my-package>.el` is
the hypothetical package we'd like to test:

#+begin_src
.
â”œâ”€â”€ .travis.yml         ;; Travis CI config
â”œâ”€â”€ .elpa               ;; contains installed deps
â”œâ”€â”€ Makefile            ;; shortcuts to test/make-*.el
â”œâ”€â”€ <my-package>.el     ;; package being tested
â””â”€â”€ test
    â”œâ”€â”€ elpa.el         ;; initialize package.el
    â”œâ”€â”€ tests.el        ;; automated tests
    â”œâ”€â”€ make-compile.el ;; compile *el files
    â”œâ”€â”€ make-test.el    ;; run automated tests
    â””â”€â”€ make-update.el  ;; install dependencies
#+end_src

These files have to be modified, the rest can be copied as is:

- `test/make-compile.el` contains the dev dependencies of the package
- `test/tests.el` contains the automated tests

The rest of the files don't need to be modified. However, if needed,
they can easily be changed since each one is small, simple, serves one
purpose, thus easy to tweak.

*** .travis.yml

This file is the entry point for Travis CI.

#+begin_src
# .travis.yml
sudo: true
dist: precise
language: emacs-elisp
env:
  matrix:
    - emacs=emacs-snapshot

before_install:
  - sudo add-apt-repository -y ppa:ubuntu-elisp
  - sudo apt-get update -qq
  - sudo apt-get install -qq $emacs

script:
  - make update
  - make compile
  - make test
#+end_src

*** Makefile

The Makefile is used for nothing but shortcuts to running the tasks.

#+begin_src
update:
	emacs -batch -l test/make-update.el

compile: clean
	emacs -batch -l test/elpa.el -l test/make-compile.el

test:
	emacs -batch -l test/elpa.el -l test/make-test.el

clean:
	rm -f *.elc

.PHONY: update compile test clean
#+end_src

*** test/elpa.el 

Initializes package.el.

#+begin_src
(setq package-user-dir
      (expand-file-name (format ".elpa/%s/elpa" emacs-version)))
(package-initialize)
(add-to-list 'load-path default-directory)
#+end_src

*** test/make-compile.el

This file compiles `*.el` files in the package root directory.

#+begin_src
;;  bail out on compilation warnings and errors
(setq byte-compile-error-on-warn t)
(setq byte-compile--use-old-handlers nil)

;; compile *.el files
(dolist (file (file-expand-wildcards "*.el"))
  (unless (byte-compile-file file)
    (kill-emacs 1)))

#+end_src

*** test/make-test.el

This file runs the tests in `tests/tests.el`.

#+begin_src
(let* ((project-tests-file "tests.el")
       (current-directory (file-name-directory load-file-name))
       (project-test-path (expand-file-name "." current-directory))
       (project-root-path (expand-file-name ".." current-directory)))

  ;; add the package being tested to 'load-path so it can be 'require-d
  (add-to-list 'load-path project-root-path)
  (add-to-list 'load-path project-test-path)

  ;; load the file with tests
  (load (expand-file-name project-tests-file project-test-path) nil t)

  ;; run the tests
  (ert-run-tests-batch-and-exit))
#+end_src

*** test/make-update.el

This file installs dependencies in the `.elpa` directory.

The `dev-packages` variable should be modified per the package's
needs. This example adds the `evil` and `evil-test-helpers` packages
as dependencies for illustrative purpose.

#+begin_src
;; list of the all the dependencies, including the dev dependencies
(defvar dev-packages '(evil evil-test-helpers))

;; initialize package.el
(setq package-user-dir
      (expand-file-name (format ".elpa/%s/elpa" emacs-version)))
(message "installing in %s ...\n" package-user-dir)
(package-initialize)
(setq package-archives
      '(("melpa" . "http://melpa.org/packages/")
        ("gnu" . "http://elpa.gnu.org/packages/")))
(package-refresh-contents)

;; install dependencies
(dolist (package dev-packages)
  (unless (package-installed-p package)
    (ignore-errors
      (package-install package))))

;; upgrade dependencies
(save-window-excursion
  (package-list-packages t)
  (condition-case nil
      (progn
        (package-menu-mark-upgrades)
        (package-menu-execute t))
    (error
     (message "All packages up to date"))))
#+end_src

*** test/tests.el

This file contains the unit tests for `my-package`, the package being
tested. This example tests a hypothetical function
`my-package-add-numers`.

#+begin_src
(require 'ert)
(require 'my-package)

(ert-deftest sample-test ()
  (ert-info ("test function my-package-add-numers")
    (should (eq 3 (my-package-add-numers 1 2))
#+end_src

*** .gitignore (optional)

#+begin_src
.elpa/
*.elc
#+end_src

# Summary

The described approach is simple in the sense that it doesn't add any
dependencies to the package, other than `make`. Everything else is
included with emacs - package.el, ert.el, etc.

The obvious disadvantage is the wordiness - this method involves
multiple files.

See also:

- [[https://github.com/cask/cask][cask]] - this seems to be a tool designed for this purpose
  solely. Haven't tried it yet.
- [[https://github.com/rejeep/evm][evm]] - a tool which allows installing multiple versions of
  emacs. Seems entangled with cask, but doesn't require it. This tool
  can be used to run the tests against multiple versions of emacs, not
  sure if it can be achieved without pulling in cask as a dependency

** Why I switched to Emacs                                           :emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: why-i-switched-to-emacs
:EXPORT_DATE: 2017-09-08
:EXPORT_DESCRIPTION: after so many years with vim.
:END:

After years of using Vim as my primary editing tool...

#+hugo: more

*** TL;DR

This January I stopped using vim after years of sharpening my vim
setup because I couldn't understand this very [[https://github.com/junegunn/vim-slash/commit/5e9d77b6][commit]].

*** The "reason"

In my mother tongue there are two different words for "reason" with
significant differences in their meaning. The first one "Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð°", is
used to describe an event or more commonly, a series of events which
lead to what usually turns out to be a bad situation. The other one
"Ð¿Ð¾Ð²Ð¾Ð´", describes the very last event, the final straw which lead to
the event.

This commit, this patch of code was the last straw, it was the reason I
would stop using my sharpened saw, my tool of trade, my Vim:

[[https://github.com/junegunn/vim-slash/commit/5e9d77b6]]

I had been following the [[https://github.com/junegunn/vim-slash][vim-slash]] repo for some time because I had a
similar functionality in my vimrc... and because I find this
particular project interesting. I like following interesting projects.

That commit fixed an issue that I had been experiencing
myself. However, even after years of using Vim and writing VimL I had
no idea how this patch would address the issue.

On one hand, this commit seems like such an elegant solution to the
problem - with just a few lines of code, the issue is completely
fixed.  On the other hand, however, this smells like such an ugly hack
that.

Up until that moment, I had been seeing VimL as an elegant solution,
such beauty, so similar to all the scripting languages I'm (painfully)
familiar with... but not more. I had seen the true side of it and I
couldn't see it in any other way.

*** The cosmic microwave background radiation

Like the cosmic microwave background radiation, emacs-lisp has been
there all along, waiting for me to discover it. And now that I have, I
can't go back, I can't deny its existence, I can't go back to VimL.

Like seeing the "SH", as in Steven Hawking, in the
cosmic microwave background radiation - once you see it, you can't
un-see it.

[[/images/2017-09-08-why-i-switched-to-emacs-ilc_9yr_moll4096.png]]
  
** Prompt working directory                           :bash:zsh:shell:prompt:
:PROPERTIES:
:EXPORT_FILE_NAME: 2014-01-26-bash-directory-truncation
:EXPORT_DATE: 2014-01-26
:EXPORT_DESCRIPTION: shorten ~/down/the/rabbit/hole to â‹¯/the/rabbit/hole in prompt
:END:

Shorten =~/very/deep/down/the/rabbit/hole= to =â‹¯/the/rabbit/hole= in
prompt.

#+hugo: more

If you're staring at a shell prompt a few hours every day, you might as well
try to modify the prompt to better suit your needs.  Some people like a
minimalistic prompt with nothing but the working dir and a dollar sign =~ $=.
Others get an enormous 256-color multi-line beast holding information about the
kernel version, battery status, daily horoscope and what not. There's yet
another group which sticks with whatever their system's default is.

This post will hopefully come in handy for the first and second group.

*** The Goal

The working directory should be readable no matter how
=~/very/deep/down/the/rabbit/hole= you're in in the file system. To maintain
readability, the working dir displayed in the prompt should contain no more
than three sub directories =â‹¯/the/rabbit/hole= 

Bash version 4+ actually has an option to do this =PROMPT_DIRTRIM=3=, but I
find it's behaviour ludicrous: it behaves (very) differently when the working
dir is a sub dir of $HOME or not.

Working dir is a subdir of $HOME:

#+begin_src
~ $ PROMPT_DIRTRIM=3
~ $ cd one/
~/one $ cd two/
~/one/two $ cd three/
~/one/two/three $ cd four/
~/one/two/three/four $ cd five/
~/.../three/four/five $
#+end_src

This is useless to me:

- Notice that when in dir =four=, the path is not truncated at all
  =~/one/two/three/four $=
- The tilde =~= is never truncated =~/.../three/four/five $=

Working dir is not a subdir of $HOME:

#+begin_src
~ $ PROMPT_DIRTRIM=3
/ $ cd one/
/one $ cd two/
/one/two $ cd three/
/one/two/three $ cd four/
.../two/three/four $ cd five/
.../three/four/five $
#+end_src

This is much better! ... or not:

- Most of the time I'm somewhere in $HOME
- I would really like to use a single char =â‹¯= instead of three dots =...=.
  Screen real-estate does not come that cheap. I work with many vim/tmux panes,
  so cutting some fat here and there does make a difference.

Also, I've been wanting to improve my shell scripting skills for some time.
This seemed like a nice challenge.

*** Truncate function

In theory, truncating the $PWD to 3 dirs seemed like a very simple task. In
practice, it turned out a (tiny) bit more complicated. In javascript (a
language I'm mostly unfamiliar with), this could be achieved with pretty much
one line of code:

(Note that this is greatly simplified and doesn't handle any corner cases.)

#+begin_src
PWD.split('/').slice(-3).join('/')
#+end_src

How hard could it be to port this to bash (and zsh)?

One thing I want to stress is that external processes must **not** be created
to achieve this task. This function must be as fast as possible and forking off
=sed=, =awd= and what not, is not a viable option.

*** The result

After some research on bash/zsh arrays, some head-banging and quite a bit of
coffee, I managed to achieve the desired result:

In a subdir of $HOME:

#+begin_src
~ $ cd one/
~/one $ cd two/
~/one/two $ cd three/
â‹¯/one/two/three $ cd four/
â‹¯/two/three/four $ cd five/
#+end_src

Not in $HOME:

#+begin_src
/ $ cd one/
/one $ cd two/
/one/two $ cd three/
â‹¯/one/two/three $ cd four/
â‹¯/two/three/four $ cd five/
#+end_src

As a bonus, the separator can be configured, for example it could be = > =

#+begin_src
~ $ cd one/
~ > one $ cd two/
~ > one > two $ cd three/
â‹¯ > one > two > three $ cd four/
â‹¯ > two > three > four $ cd five/
#+end_src

Plus, with some minor modifications, I got the function working with powerline
symbols for my [promptline.vim][1] plugin:

{% img /images/promptline_cwd.png %}

*** The function itself

Hopefully it would be useful to someone else. I certainly learned a lot writing
(and re-writing) it. Enjoy!

#+begin_src
function truncated_cwd {
  # dir_limit and truncation can be configured
  local dir_limit="3"
  local truncation="â‹¯"

  local first_char
  local part_count=0
  local formatted_cwd=""
  local dir_sep=" | "

  local cwd="${PWD/#$HOME/~}"

  # get first char of the path, i.e. tilde or slash
  [[ -n ${ZSH_VERSION-} ]] && first_char=$cwd[1,1] || first_char=${cwd::1}

  # remove leading tilde
  cwd="${cwd#\~}"

  while [[ "$cwd" == */* && "$cwd" != "/" ]]; do
    # pop off last part of cwd
    local part="${cwd##*/}"
    cwd="${cwd%/*}"

    formatted_cwd="$dir_sep$part$formatted_cwd"
    part_count=$((part_count+1))

    [[ $part_count -eq $dir_limit ]] && first_char="$truncation" && break
  done

  [[ "$formatted_cwd" != $first_char* ]] && formatted_cwd="$first_char$formatted_cwd"
  printf "%s" "$formatted_cwd"
}
#+end_src

There are a few ways to get the function in the prompt, this is probably the
simplest one: 

#+begin_src
PS1='$(truncated_cwd) \$ '
#+end_src

[1]: https://github.com/edkolev/promptline.vim

